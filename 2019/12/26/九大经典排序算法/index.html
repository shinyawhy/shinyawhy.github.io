<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>九大经典排序算法 | XyLan</title><meta name="description" content="九大经典排序算法"><meta name="keywords" content=""><meta name="author" content="XyLan"><meta name="copyright" content="XyLan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="九大经典排序算法"><meta name="twitter:description" content="九大经典排序算法"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="九大经典排序算法"><meta property="og:url" content="https://blog.xylan.cn/2019/12/26/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="XyLan"><meta property="og:description" content="九大经典排序算法"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="https://blog.xylan.cn/2019/12/26/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><link rel="prev" title=" 图的深度优先遍历和广度优先遍历代码实现" href="https://blog.xylan.cn/2020/01/13/%20%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"><link rel="next" title="Qt学习笔记13-QStringListModel" href="https://blog.xylan.cn/2019/12/06/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013-QStringListModel/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"简","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: XyLan","link":"链接: https://blog.xylan.cn/2019/12/26/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","source":"来源: XyLan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">XyLan</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">30</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#九大经典排序算法"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">九大经典排序算法</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#九大经典排序算法"><span class="toc-number">1.</span> <span class="toc-text">九大经典排序算法</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">九大经典排序算法</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-12-26<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-26</time><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="九大经典排序算法"><a href="#九大经典排序算法" class="headerlink" title="九大经典排序算法"></a>九大经典排序算法</h1><p>1.1 直接插入排序（Insertion Sort）</p>
<p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据在已排序序列中从前向后扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从前向后的扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>在所有的简单排序（算法性能为O(n^2)）中，直接插入排序的整体性能最好。</p>
<p>1.2 希尔排序(Shellsort)</p>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。</p>
<p>Shellsort, also known as Shell sort or Shell’s method, is an in-place comparison sort. It can be seen as either a generalization of sorting by exchange (bubble sort) or sorting by insertion (insertion sort). The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared. Starting with far apart elements, it can move some out-of-place elements into position faster than a simple nearest neighbor exchange. Donald Shell published the first version of this sort in 1959. The running time of Shellsort is heavily dependent on the gap sequence it uses. For many practical variants, determining their time complexity remains an open problem.</p>
<p>稳定性：<br>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<p>1.3 冒泡排序</p>
<p>Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements “bubble” to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems even when compared to insertion sort. It can be practical if the input is usually in sorted order but may occasionally have some out-of-order elements nearly in position.</p>
<p>1.4 快速排序(Quicksort)</p>
<p>快速排序采用分治策略，其难点在于如何取得轴点（Pivot Points），也就是如何分（divide）的问题。</p>
<p>Quicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order. Developed by Tony Hoare in 1959 and published in 1961, it is still a commonly used algorithm for sorting. When implemented well, it can be about two or three times faster than its main competitors, merge sort and heapsort.<br>Quicksort is a comparison sort, meaning that it can sort items of any type for which a “less-than” relation (formally, a total order) is defined. In efficient implementations it is not a stable sort, meaning that the relative order of equal sort items is not preserved. Quicksort can operate in-place on an array, requiring small additional amounts of memory to perform the sorting.</p>
<p>1.5 简单选择排序(Simple Selection Sort)</p>
<p>选择排序是一种简单直观的排序算法。算法特点:每经过一趟排序都能得到全局的最大（小）值。</p>
<p>1.6 堆排序(Heapsort)</p>
<p>堆排序（Heapsort）是一种高级的选择排序，是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：<br>父节点i的左子节点在位置(2<em>i+1);<br>父节点i的右子节点在位置(2</em>i+2);<br>子节点i的父节点在位置(i-1)/2;</p>
<p>相关历史：<br>Heapsort was invented by J. W. J. Williams in 1964. This was also the birth of the heap, presented already by Williams as a useful data structure in its own right. In the same year, R. W. Floyd published an improved version that could sort an array in-place, continuing his earlier research into the treesort algorithm.</p>
<p>1.7 归并排序(Merge Sort)</p>
<p>归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼(John von Neumann)首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<p>1.8 计数排序(Counting Sort)</p>
<p>计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组Cnt，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组Cnt来将A中的元素排到正确的位置。</p>
<p>Although radix sorting itself dates back far longer(1887), counting sort, and its application to radix sorting, were both invented by Harold H. Seward in 1954.</p>
<p>1.9 基数排序（Radix Sort）</p>
<p>基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼(Herman Hollerith)在打孔卡片制表机（Tabulation Machine）上的贡献。<br>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。<br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">// main.cpp </span><br><span class="line">//直接插入排序 希尔排序 冒泡排序（简单交换排序） 快速排序 简单选择排序 堆排序</span><br><span class="line">//2路-归并排序 计数排序 基数排序 </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 10</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_InsertSort_Straight(int* a, int n);</span><br><span class="line">void test_InsertSort_Shell(int* a, int n);</span><br><span class="line">void test_SwapSort_Bubble(int* a, int n);</span><br><span class="line">void test_SwapSort_Quick(int* a, int n);</span><br><span class="line">void test_SelectionSort_Simple(int* a, int n);</span><br><span class="line">void test_SelectionSort_Heap(int* a, int n);</span><br><span class="line">void test_MergeSort_2(int* a, int n);</span><br><span class="line">void test_RadixSort_Count(int* a, int n);</span><br><span class="line">void test_RadixSort_Radix(int* a, int n);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_InsertSort()</span><br><span class="line">&#123;</span><br><span class="line">	int a[N] = &#123;21, 26, 5, 96, 45, 12, 26, 14, 15, 12&#125;;</span><br><span class="line">	cout &lt;&lt; &quot;原始数据如下&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">	for(int i = 0; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; left &lt;&lt; setw(4) &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	//测试直接插入排序</span><br><span class="line">	test_InsertSort_Straight(a, N);</span><br><span class="line">	//测试希尔排序</span><br><span class="line">	test_InsertSort_Shell(a, N);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_SelectionSort()</span><br><span class="line">&#123;</span><br><span class="line">	int a[N] = &#123;21, 26, 5, 96, 45, 12, 26, 14, 15, 12&#125;;</span><br><span class="line">	cout &lt;&lt; &quot;原始数据如下&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">	for(int i = 0; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; left &lt;&lt; setw(4) &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	//测试简单选择排序</span><br><span class="line">	test_SelectionSort_Simple(a, N);</span><br><span class="line">	//测试堆排序</span><br><span class="line">	test_SelectionSort_Heap(a, N);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_SwapSort()</span><br><span class="line">&#123;</span><br><span class="line">	int a[N] = &#123;21, 26, 5, 96, 45, 12, 26, 14, 15, 12&#125;;</span><br><span class="line">	cout &lt;&lt; &quot;原始数据如下&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">	for(int i = 0; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; left &lt;&lt; setw(4) &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	////测试冒泡排序</span><br><span class="line">	test_SwapSort_Bubble(a, N);</span><br><span class="line">	//测试快速排序</span><br><span class="line">	test_SwapSort_Quick(a, N);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_MergeSort()</span><br><span class="line">&#123;</span><br><span class="line">	int a[N] = &#123;21, 26, 5, 96, 45, 12, 26, 14, 15, 12&#125;;</span><br><span class="line">	cout &lt;&lt; &quot;原始数据如下&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">	for(int i = 0; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; left &lt;&lt; setw(4) &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	//2路-归并排序</span><br><span class="line">	test_MergeSort_2(a, N);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_RadixSort()</span><br><span class="line">&#123;</span><br><span class="line">	int a[N] = &#123;21, 26, 5, 96, 45, 12, 26, 14, 15, 12&#125;;</span><br><span class="line">	cout &lt;&lt; &quot;原始数据如下&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">	for(int i = 0; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; left &lt;&lt; setw(4) &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	//计数排序</span><br><span class="line">	test_RadixSort_Count(a, N);</span><br><span class="line">	//基数排序</span><br><span class="line">	test_RadixSort_Radix(a, N);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//所有的排序目的都是排出由小到大的顺序</span><br><span class="line">	//test_InsertSort();</span><br><span class="line">	//test_SwapSort();</span><br><span class="line">	//test_SelectionSort();</span><br><span class="line">	//test_MergeSort();</span><br><span class="line">	test_RadixSort();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">//01InsertSort.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">static void print(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; left &lt;&lt; setw(4) &lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test_InsertSort_Straight(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">    //对比shell排序，这里st=0；step=1；</span><br><span class="line">    for(int i = 0 + 1; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //存储当前待比较的变量</span><br><span class="line">        int tem = a[i];</span><br><span class="line">        int j = i;</span><br><span class="line">        for(; 1 &lt;= j &amp;&amp; tem &lt; a[j - 1]; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            //元素后移</span><br><span class="line">            a[j] = a[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;直接插入排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">    print(a, n);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//对数组a作一趟希尔插入排序。本算法和一趟直接插入排序相比，做了一下修改：</span><br><span class="line">//   1.前后记录位置的增量为step，而不是1</span><br><span class="line">static void ShellInsert(int* a, int n, int step)</span><br><span class="line">&#123;</span><br><span class="line">    for(int st = 0; st &lt; step; ++st)</span><br><span class="line">    &#123;</span><br><span class="line">        //这边就是直接插入排序</span><br><span class="line">        for(int i = st + step; i &lt; n; i += step)</span><br><span class="line">        &#123;</span><br><span class="line">            int tem = a[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            for(; step &lt;= j &amp;&amp; tem &lt; a[j - step]; j -= step)</span><br><span class="line">            &#123;</span><br><span class="line">                //元素后移</span><br><span class="line">                a[j] = a[j - step]</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*cout &lt;&lt; &quot;步长为&quot; &lt;&lt; step &lt;&lt; &quot;, 希尔排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;*/</span><br><span class="line">&#125;</span><br><span class="line"> void test_InsertSort_Shell(int* a, int n)</span><br><span class="line"> &#123;</span><br><span class="line">     //stepInc位置的增量</span><br><span class="line">	for(int stepInc = n &gt;&gt; 1; 1 &lt;= stepInc; stepInc &gt;&gt;= 1)</span><br><span class="line">	&#123;</span><br><span class="line">		ShellInsert(a, n, stepInc);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;希尔排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> //WARNING:  点评：自己写的简单插入排序，用到了swap。其实免去这个操作。做到真正的只插入。</span><br><span class="line">void Mytest_InsertSort_Straight(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	for(int i = 1; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j = i; 0 &lt; j; --j)</span><br><span class="line">		&#123;</span><br><span class="line">			if(a[j] &lt; a[j - 1])</span><br><span class="line">			&#123;</span><br><span class="line">				//如果a[j-1]大于a[j]的时候，对换二者</span><br><span class="line">				swap(a[j], a[j - 1]);</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				//说明数组a[0,..,j]部分已经排序成功，直接跳出循环</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;直接插入排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">// 02SwapSort.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static void swap(int&amp; a, int&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	int tem = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tem;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static void print(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; left &lt;&lt; setw(4) &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_SwapSort_Bubble(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = 0; i &lt; n - 1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		bool isSorted = true;</span><br><span class="line">		for(int j = 0; j &lt; n - i - 1; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			if(a[j + 1] &lt; a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(a[j], a[j + 1]);</span><br><span class="line">				isSorted = false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(true == isSorted)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;冒泡排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//点评：没有考虑提前退出的情况</span><br><span class="line">void Mytest_SwapSort_Bubble(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = 0; i &lt; n -1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j = 0; j &lt; n - i - 1; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			if(a[j + 1] &lt; a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(a[j], a[j + 1]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;冒泡排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static int getMiddleID(int* a, int st, int mid, int ed)</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line">	if(a[st] &lt; a[mid])</span><br><span class="line">	&#123;</span><br><span class="line">		if(a[mid] &lt; a[ed])</span><br><span class="line">		&#123;</span><br><span class="line">			res = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			res = a[st] &lt; a[ed] ? ed : st;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		if(a[ed] &lt; a[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			res = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			res = a[st] &gt; a[ed] ? ed : st;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//获取轴点的位置，此时轴点之前的记录均不大于轴点的值，轴点之后的记录均小于轴点的值</span><br><span class="line">static int Partition(int* a, int st, int ed)</span><br><span class="line">&#123;</span><br><span class="line">	/*int stPos = getMiddleID(a, st, (ed - st) / 2, ed);</span><br><span class="line">	swap(a[st], a[stPos]);*/</span><br><span class="line">	int tem = a[st];</span><br><span class="line">	while(st &lt; ed)</span><br><span class="line">	&#123;</span><br><span class="line">		//ERROR:这两次while当中，至少要出现一次等于&lt;=,否则对于相等元素，会陷入无限循环中；</span><br><span class="line">		//轴点之后的记录均小于轴点的值</span><br><span class="line">		while(st &lt; ed&amp;&amp;tem &lt; a[ed])</span><br><span class="line">		&#123;</span><br><span class="line">			--ed;</span><br><span class="line">		&#125;</span><br><span class="line">		a[st] = a[ed];</span><br><span class="line">		//轴点之前的记录均不大于轴点的值</span><br><span class="line">		while(st &lt; ed&amp;&amp;a[st] &lt;= tem)</span><br><span class="line">		&#123;</span><br><span class="line">			++st;</span><br><span class="line">		&#125;</span><br><span class="line">		a[ed] = a[st];</span><br><span class="line">	&#125;</span><br><span class="line">	a[st] = tem;</span><br><span class="line">	return st;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//快速排序算法</span><br><span class="line">static void QuickSort(int* a, int st, int ed)</span><br><span class="line">&#123;</span><br><span class="line">	if(st &lt; ed)</span><br><span class="line">	&#123;</span><br><span class="line">		//pivot 轴点</span><br><span class="line">		int pivotLoc = Partition(a, st, ed);</span><br><span class="line">		QuickSort(a, st, pivotLoc - 1);</span><br><span class="line">		QuickSort(a, pivotLoc + 1, ed);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_SwapSort_Quick(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	//对于初始点的选择，从数组元素的起点，中点和终点三者当中，选择中间大的数作为起点。</span><br><span class="line">	//int stPos = getMiddleID(a, n, 0, (n - 1) / 2, n - 1);</span><br><span class="line">	QuickSort(a, 0, n - 1);</span><br><span class="line">	cout &lt;&lt; &quot;快速排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// 03SelectionSort.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static void swap(int&amp; a, int&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	int tem = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tem;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static void print(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; left &lt;&lt; setw(4) &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_SelectionSort_Simple(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		int minIdx = i;</span><br><span class="line">		for(int j = i + 1; j &lt; n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			if(a[j] &lt; a[minIdx])</span><br><span class="line">			&#123;</span><br><span class="line">				minIdx = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(i != minIdx)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(a[i], a[minIdx]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;简单选择排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//n表示数组的长度， adjPos表示需要调整的堆的位置；</span><br><span class="line">//堆的调整都是默认顶点下面的子树都已经是大根堆</span><br><span class="line">static void HeapAdjust(int* a, int n, int adjPos)</span><br><span class="line">&#123;</span><br><span class="line">	int adjVal = a[adjPos];</span><br><span class="line">	//ERROR:i = 2*i +1代表的意思就是i指向其左孩子   注意不是i= 2*i</span><br><span class="line">	for(int i = 2 * adjPos + 1; i &lt; n; i = 2*i +1)</span><br><span class="line">	&#123;</span><br><span class="line">		//如果存在右孩子的话，比较二者，取其中较大者的位序</span><br><span class="line">		if(i &lt; n - 1 &amp;&amp; a[i] &lt; a[i + 1])</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		//如果孩子结点的最大值都小于adjVal，则调整提前结束</span><br><span class="line">		if(a[i] &lt; adjVal)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		//依次将元素往上移</span><br><span class="line">		a[adjPos] = a[i];</span><br><span class="line">		adjPos = i;</span><br><span class="line">	&#125;</span><br><span class="line">	a[adjPos] = adjVal;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//建立大根堆，以便从小到大进行排序</span><br><span class="line">static void createMaxHeap(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = (n - 2) / 2; 0 &lt;= i; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		HeapAdjust(a, n, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_SelectionSort_Heap(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	//建立大根堆</span><br><span class="line">	createMaxHeap(a, n);</span><br><span class="line">	//依次将顶元素和最后一个元素进行交换，逐渐排序</span><br><span class="line">	for(int i = n - 1; 0 &lt;= i; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(a[0], a[i]);</span><br><span class="line">		HeapAdjust(a, i, 0);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; &quot;堆排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// 04MergeSort.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static void print(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; left &lt;&lt; setw(4) &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static void merge(int* a, int st, int mid, int ed)</span><br><span class="line">&#123;</span><br><span class="line">	int* b = new int[mid - st + 1];</span><br><span class="line">	//ERROR：对于b[]复制存在错误，不是每次从a[0]开始复制，而是从st开始复制</span><br><span class="line">	/*for(int i = 0; i &lt;= mid; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">	b[i] = a[i];</span><br><span class="line">	&#125;*/</span><br><span class="line">	for(int i = 0; i &lt; mid - st + 1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] = a[i + st];</span><br><span class="line">	&#125;</span><br><span class="line">	//ERROR:这里int k = st;注意不是k = 0</span><br><span class="line">	int k = st;</span><br><span class="line">	for(int i = st, j = mid + 1; i &lt;= mid || j &lt;= ed;)</span><br><span class="line">	&#123;</span><br><span class="line">		//注意b[i - st] &lt;= a[j]此处，必须与下面的a[j] &lt; b[i - st]，构成封闭的集合</span><br><span class="line">		//ERROR：未能考虑等于号</span><br><span class="line">		if((i &lt;= mid&amp;&amp;j &lt;= ed&amp;&amp;b[i - st] &lt;= a[j]) || ed &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			a[k++] = b[i - st];</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(i &lt;= mid&amp;&amp;j &lt;= ed &amp;&amp; a[j] &lt; b[i - st])</span><br><span class="line">		&#123;</span><br><span class="line">			a[k++] = a[j];</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete[] b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static void  mergeSort(int* a, int st, int ed)</span><br><span class="line">&#123;</span><br><span class="line">	if(st &lt; ed)</span><br><span class="line">	&#123;</span><br><span class="line">		int mid = st + (ed - st) / 2;</span><br><span class="line">		mergeSort(a, st, mid);</span><br><span class="line">		mergeSort(a, mid + 1, ed);</span><br><span class="line">		merge(a, st, mid, ed);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_MergeSort_2(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	mergeSort(a, 0, n - 1);</span><br><span class="line">	cout &lt;&lt; &quot;归并排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">// 05RadixSort.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static void print(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; left &lt;&lt; setw(4) &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//假设数组元素在0~99之间，进行取值</span><br><span class="line">//计数排序</span><br><span class="line">void test_RadixSort_Count(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	//计数数组</span><br><span class="line">	int* cnt = new int[100];</span><br><span class="line">	memset(cnt, 0, sizeof(int) * 100);</span><br><span class="line">	</span><br><span class="line">	//此时，cnt[a[i]]表示值为a[i]的元素在数组a当中出现的次数</span><br><span class="line">	//WARNING: 注意这里i &lt; n,不是i &lt; 100</span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		++cnt[a[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	//此时，cnt[i] - 1表示值为i的元素在数组a中排序之后的最大可能位置</span><br><span class="line">	//ERROR: 注意这里i &lt; 100,不是i &lt; n</span><br><span class="line">	for(int i = 1; i &lt; 100; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt[i] += cnt[i - 1];</span><br><span class="line">	&#125;</span><br><span class="line">	//tmp[]临时数组，将数组a复制到数组tmp中去</span><br><span class="line">	int* tmp = new int[n];</span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp[i] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	////ERROR:计数排序,这样虽然也能得到正确结果，但是不能保证排序的稳定性</span><br><span class="line">	//for(int i = 0; i &lt; n; ++i)</span><br><span class="line">	//&#123;</span><br><span class="line">	//	a[--cnt[tmp[i]]] = tmp[i];</span><br><span class="line">	//&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	//稳定版：计数排序</span><br><span class="line">	for(int i = n-1; 0 &lt;= i; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		a[--cnt[tmp[i]]] = tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; &quot;计数排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	delete[] cnt;</span><br><span class="line">	delete[] tmp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static int getRadix(int num, int sq, int RADIX)</span><br><span class="line">&#123;</span><br><span class="line">	return (num / (int)pow(RADIX, sq)) % RADIX;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static void Distribute(int* a, int n, int sq, int* cnt, int* tmp, int RADIX)</span><br><span class="line">&#123;</span><br><span class="line">	memset(cnt, 0, sizeof(int)*RADIX);</span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		int ord = getRadix(a[i], sq, RADIX);</span><br><span class="line">		++cnt[ord];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static void Collect(int* a, int n, int sq, int* cnt, int* tmp, int RADIX)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i = 1; i &lt; RADIX; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt[i] += cnt[i - 1];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp[i] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = n - 1; 0 &lt;= i; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		int ord = getRadix(tmp[i], sq, RADIX);</span><br><span class="line">		a[--cnt[ord]] = tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void test_RadixSort_Radix(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int keyNum = 2;</span><br><span class="line">	int RADIX = 10;</span><br><span class="line">	int* cnt = new int[RADIX];</span><br><span class="line">	int* tmp = new int[n];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; keyNum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Distribute(a, n, i, cnt, tmp, RADIX);</span><br><span class="line">		Collect(a, n, i, cnt, tmp, RADIX);</span><br><span class="line">		cout &lt;&lt; i + 1 &lt;&lt; &quot;次基数排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">		print(a, n);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;基数排序之后的结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">	print(a, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	delete[] cnt;</span><br><span class="line">	delete[] tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">XyLan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.xylan.cn/2019/12/26/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">https://blog.xylan.cn/2019/12/26/%E4%B9%9D%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.xylan.cn">XyLan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/01/13/%20%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span> 图的深度优先遍历和广度优先遍历代码实现</span></div></a></div><div class="next-post pull_right"><a href="/2019/12/06/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013-QStringListModel/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Qt学习笔记13-QStringListModel</span></div></a></div></nav></div></div><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2021 By XyLan</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/baidupush.js"> </script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>